# Git origin と pull の完全ガイド：リモートリポジトリとの紐付け

## originとは何か

`origin`は**リモートリポジトリのデフォルト名**です。単なる「名前」であり、特別な意味はありません。

```bash
# originは慣習的な名前
origin = リモートリポジトリの別名（エイリアス）

# 実際にはURLを指している
origin → https://github.com/username/repository.git
```

## リモートリポジトリとの紐付け方法

### パターン1: git cloneで紐付け（推奨）

```bash
# リポジトリをクローン
git clone https://github.com/username/myproject.git

# 自動的にoriginが設定される
cd myproject
git remote -v
# origin  https://github.com/username/myproject.git (fetch)
# origin  https://github.com/username/myproject.git (push)
```

**内部で何が起きているか：**

```
1. リモートからすべてのデータをダウンロード
2. .git/config にorigin情報を追加
3. ワークツリーにファイルを展開
4. HEADをmainブランチに設定
```

**.git/config の内容：**

```ini
[remote "origin"]
    url = https://github.com/username/myproject.git
    fetch = +refs/heads/*:refs/remotes/origin/*

[branch "main"]
    remote = origin
    merge = refs/heads/main
```

### パターン2: 既存プロジェクトにoriginを追加

```bash
# ローカルでプロジェクト開始
mkdir myproject
cd myproject
git init

# ファイル作成とコミット
echo "# My Project" > README.md
git add README.md
git commit -m "Initial commit"

# リモートリポジトリを追加
git remote add origin https://github.com/username/myproject.git

# 紐付けを確認
git remote -v
# origin  https://github.com/username/myproject.git (fetch)
# origin  https://github.com/username/myproject.git (push)
```

**内部で何が起きているか：**

```
1. .git/config にoriginのエントリを追加

[remote "origin"]
    url = https://github.com/username/myproject.git
    fetch = +refs/heads/*:refs/remotes/origin/*

2. まだリモート追跡ブランチは作成されていない
   （初回fetch/pullで作成される）
```

## .git/configでの紐付け情報

### リモート設定の構造

```ini
[remote "origin"]
    url = https://github.com/username/myproject.git
    fetch = +refs/heads/*:refs/remotes/origin/*
```

**各パラメータの意味：**

- `url`: リモートリポジトリのURL
- `fetch`: フェッチ時のrefspec（参照の対応関係）

### refspecとは

```bash
+refs/heads/*:refs/remotes/origin/*
│└─ 強制     │         └─ ローカルの保存先
│            └─ リモートのブランチ
└─ 強制更新フラグ（省略可能）

意味：
リモートの refs/heads/* (すべてのブランチ)を
ローカルの refs/remotes/origin/* に保存する
```

### ブランチの紐付け（upstream設定）

```ini
[branch "main"]
    remote = origin
    merge = refs/heads/main
```

**意味：**
- `main`ブランチは`origin`リモートと紐付いている
- `origin`の`main`ブランチを追跡する
- `git pull`を引数なしで実行すると、`origin/main`から取得

## git pullの内部実装

### pullの基本

```bash
git pull origin main
```

**実は、pullは2つのコマンドの組み合わせ：**

```bash
git pull = git fetch + git merge
```

### git pullの詳細な内部動作

#### ステップ1: git fetch（データ取得）

```bash
# 内部的に実行される
git fetch origin main
```

**フェッチの内部処理：**

```
1. リモートとの接続確立
   - SSH/HTTPSプロトコルでGitHubに接続
   
2. リモートの参照を確認
   - refs/heads/main が指すコミットを取得
   
3. ローカルにないオブジェクトを特定
   - リモートのコミット履歴を確認
   - ローカルの .git/objects/ と比較
   
4. 必要なオブジェクトをダウンロード
   - commit オブジェクト
   - tree オブジェクト
   - blob オブジェクト
   - パックファイル形式で効率的に転送
   
5. .git/objects/ に保存
   
6. リモート追跡ブランチを更新
   .git/refs/remotes/origin/main を更新
```

**具体例：**

```
リモート（GitHub）:
refs/heads/main → commit abc123

フェッチ前のローカル:
refs/heads/main         → commit def456
refs/remotes/origin/main → commit def456

フェッチ実行:
1. abc123のcommitオブジェクトをダウンロード
2. 関連するtree, blobオブジェクトをダウンロード
3. .git/objects/ に保存

フェッチ後のローカル:
refs/heads/main         → commit def456 (変更なし)
refs/remotes/origin/main → commit abc123 (更新！)
```

#### ステップ2: git merge（マージ）

```bash
# 内部的に実行される
git merge origin/main
```

**マージの内部処理：**

```
1. 現在のブランチのコミット確認
   HEAD → refs/heads/main → commit def456

2. マージ対象の確認
   refs/remotes/origin/main → commit abc123

3. 共通の祖先（マージベース）を探す
   - def456 と abc123 の共通祖先コミットを検索
   
4. マージ戦略の決定
   
   【ケース1: Fast-forward マージ】
   現在のブランチがリモートの祖先
   
   main:     A - B - C (def456)
   origin/main: A - B - C - D - E (abc123)
                        ↑
                      共通祖先
   
   → 単純にポインタを移動
   
   【ケース2: 3-way マージ】
   両方に異なるコミットがある
   
   main:        A - B - C - D (def456)
                     ↓
   origin/main: A - B - E - F (abc123)
   
   → マージコミットを作成
   
5. マージ実行
   
6. ワークツリーを更新
   - 新しいtreeオブジェクトに基づいてファイルを展開
   
7. インデックスを更新
   - .git/index を更新
   
8. HEADを更新
   refs/heads/main を新しいコミットに更新
```

## リモート追跡ブランチとは

```bash
# ブランチの種類を確認
git branch -a

# ローカルブランチ
* main
  develop

# リモート追跡ブランチ
  remotes/origin/main
  remotes/origin/develop
```

### リモート追跡ブランチの役割

```
リモート追跡ブランチ = リモートの状態のローカルコピー

.git/refs/remotes/origin/main
└─ 最後にfetchした時点での origin/main の状態

役割：
- リモートとローカルの差分を知る
- オフラインでもリモートの状態を参照できる
- git pull/push の基準点
```

### ディレクトリ構造

```bash
.git/refs/
├── heads/              # ローカルブランチ
│   ├── main           # あなたの作業ブランチ
│   └── develop
└── remotes/           # リモート追跡ブランチ
    └── origin/
        ├── main       # リモートのmainの状態
        └── develop    # リモートのdevelopの状態
```

## git pullの詳細な例

### 例1: Fast-forward マージ

```bash
# 初期状態
git log --oneline --graph --all
# * d3c2b1a (origin/main) Update feature
# * b2a1f9e Fix bug
# * a1f2e3d (HEAD -> main) Initial commit

# pullを実行
git pull origin main
```

**内部動作：**

```
1. Fetch
   - リモートの最新状態を取得
   - origin/main を d3c2b1a に更新
   
2. Merge（Fast-forward）
   - 現在のmain (a1f2e3d) は origin/main (d3c2b1a) の祖先
   - ポインタを単純に移動
   
   refs/heads/main: a1f2e3d → d3c2b1a
   
3. ワークツリーを更新
   - d3c2b1a の tree オブジェクトを読み込み
   - ファイルを展開

# 結果
git log --oneline --graph --all
# * d3c2b1a (HEAD -> main, origin/main) Update feature
# * b2a1f9e Fix bug
# * a1f2e3d Initial commit
```

### 例2: 3-way マージ

```bash
# 初期状態（ローカルとリモートに異なるコミット）
git log --oneline --graph --all
# * e4d3c2b (HEAD -> main) Local work
# | * d3c2b1a (origin/main) Remote work
# |/
# * a1f2e3d Common ancestor

# pullを実行
git pull origin main
```

**内部動作：**

```
1. Fetch
   - リモートの d3c2b1a とその履歴を取得
   
2. Merge（3-way merge）
   - 共通祖先: a1f2e3d
   - ローカル: e4d3c2b
   - リモート: d3c2b1a
   
   a. 3つのtreeオブジェクトを比較
      - 共通祖先のtree
      - ローカルのtree
      - リモートのtree
      
   b. 差分を統合
      - ファイルごとに変更を統合
      - コンフリクトがあれば検出
      
   c. 新しいtreeオブジェクトを作成
      → SHA-1: f5e6d7c...
      
   d. マージコミットを作成
      tree f5e6d7c...
      parent e4d3c2b (ローカル)
      parent d3c2b1a (リモート)
      author ...
      
      Merge branch 'main' of github.com:user/repo
      → SHA-1: g6f7e8d...
      
   e. refs/heads/main を g6f7e8d に更新

# 結果
git log --oneline --graph --all
# *   g6f7e8d (HEAD -> main) Merge branch 'main'
# |\
# | * d3c2b1a (origin/main) Remote work
# * | e4d3c2b Local work
# |/
# * a1f2e3d Common ancestor
```

### 例3: コンフリクトが発生した場合

```bash
git pull origin main
# Auto-merging file.txt
# CONFLICT (content): Merge conflict in file.txt
# Automatic merge failed; fix conflicts and then commit the result.
```

**内部動作：**

```
1. Fetch（正常完了）
   
2. Merge開始
   - 3-way mergeを試みる
   - file.txt で衝突を検出
   
3. コンフリクトマーカーを挿入
   ワークツリーの file.txt:
   
   <<<<<<< HEAD
   Local changes
   =======
   Remote changes
   >>>>>>> d3c2b1a
   
4. .git/index に特別なエントリを作成
   - stage 1: 共通祖先版
   - stage 2: ローカル版（HEAD）
   - stage 3: リモート版（origin/main）
   
5. マージを中断（未完了状態）
   - .git/MERGE_HEAD ファイルを作成
     → マージ中のコミットIDを記録
   - .git/MERGE_MODE ファイルを作成

# インデックスの状態を確認
git ls-files --stage file.txt
# 100644 abc123... 1  file.txt  (共通祖先)
# 100644 def456... 2  file.txt  (ローカル)
# 100644 ghi789... 3  file.txt  (リモート)
```

**コンフリクト解決：**

```bash
# 1. ファイルを手動で編集
vim file.txt
# コンフリクトマーカーを削除し、正しい内容に修正

# 2. ステージング
git add file.txt
# → .git/index から stage 1,2,3 のエントリを削除
# → stage 0 の通常エントリを追加

# 3. マージコミット完了
git commit
# → .git/MERGE_HEAD を読み込み
# → 2つの親を持つマージコミットを作成
# → .git/MERGE_HEAD と .git/MERGE_MODE を削除
```

## git fetch vs git pull

### git fetch（安全）

```bash
git fetch origin main
```

**動作：**
- リモートの情報を取得
- `refs/remotes/origin/main` を更新
- ローカルブランチは変更しない
- ワークツリーは変更しない

**使用場面：**
- リモートの状態を確認したい
- マージする前に差分を見たい
- 安全にリモート情報を取得したい

```bash
# フェッチ後に差分を確認
git fetch origin main
git log main..origin/main    # リモートの新しいコミット
git diff main origin/main    # 詳細な差分

# 問題なければマージ
git merge origin/main
```

### git pull（直接マージ）

```bash
git pull origin main
```

**動作：**
- リモートの情報を取得
- 即座にマージ
- ワークツリーを更新

**リスク：**
- 予期しないマージが発生する可能性
- コンフリクトが即座に発生
- 作業中のファイルに影響

## upstreamブランチの設定

### 上流ブランチ（upstream）とは

```bash
# ローカルブランチとリモートブランチの紐付け

main ──(追跡)──> origin/main

この設定により：
- git pull を引数なしで実行可能
- git push を引数なしで実行可能
- git status でリモートとの差分表示
```

### upstream設定方法

#### 方法1: 初回プッシュ時に設定

```bash
# -uオプションでupstreamを設定
git push -u origin main

# または --set-upstream
git push --set-upstream origin main
```

**内部動作：**

```
1. コミットをプッシュ

2. .git/config に追加
   [branch "main"]
       remote = origin
       merge = refs/heads/main

3. これ以降、引数なしで実行可能
   git pull   # = git pull origin main
   git push   # = git push origin main
```

#### 方法2: 既存ブランチに設定

```bash
# upstreamを設定
git branch --set-upstream-to=origin/main main

# または短縮形
git branch -u origin/main main
```

#### 方法3: チェックアウト時に自動設定

```bash
# リモートブランチをチェックアウト
git checkout main

# origin/main が存在する場合、自動的に追跡ブランチとして設定される
```

### upstream確認

```bash
# 現在のブランチのupstream確認
git branch -vv
# * main    a1b2c3d [origin/main] Latest commit
#   develop d4e5f6g [origin/develop: ahead 2] Working on feature

# 意味：
# [origin/main] → upstreamはorigin/main
# [ahead 2]     → ローカルがリモートより2コミット進んでいる
# [behind 3]    → ローカルがリモートより3コミット遅れている
```

## 複数のリモートリポジトリ

### 複数リモートの追加

```bash
# メインリポジトリ（origin）
git remote add origin https://github.com/myuser/myrepo.git

# フォーク元（upstream）
git remote add upstream https://github.com/original/repo.git

# バックアップ
git remote add backup https://gitlab.com/myuser/myrepo.git

# 確認
git remote -v
# origin    https://github.com/myuser/myrepo.git (fetch)
# origin    https://github.com/myuser/myrepo.git (push)
# upstream  https://github.com/original/repo.git (fetch)
# upstream  https://github.com/original/repo.git (push)
# backup    https://gitlab.com/myuser/myrepo.git (fetch)
# backup    https://gitlab.com/myuser/myrepo.git (push)
```

### .git/config の状態

```ini
[remote "origin"]
    url = https://github.com/myuser/myrepo.git
    fetch = +refs/heads/*:refs/remotes/origin/*

[remote "upstream"]
    url = https://github.com/original/repo.git
    fetch = +refs/heads/*:refs/remotes/upstream/*

[remote "backup"]
    url = https://gitlab.com/myuser/myrepo.git
    fetch = +refs/heads/*:refs/remotes/backup/*
```

### 複数リモートからの取得

```bash
# originから取得
git fetch origin

# upstreamから取得
git fetch upstream

# すべてのリモートから取得
git fetch --all
```

**ディレクトリ構造：**

```
.git/refs/remotes/
├── origin/
│   ├── main
│   └── develop
├── upstream/
│   ├── main
│   └── develop
└── backup/
    └── main
```

## git pullのオプション

### --rebase オプション

```bash
# マージの代わりにリベースを使用
git pull --rebase origin main
```

**動作の違い：**

```
通常のpull（merge）:
  A - B - C (main)
       \
        D - E (origin/main)
         \
          M (マージコミット)

pull --rebase:
  A - B - D - E - C' (履歴が一直線)
```

**内部動作：**

```
1. git fetch origin main

2. git rebase origin/main（mergeではない）
   a. ローカルの独自コミットを一時保存
   b. origin/main の状態に移動
   c. 保存したコミットを再適用
```

### --ff-only オプション

```bash
# Fast-forwardできる場合のみpull
git pull --ff-only origin main
```

**用途：**
- マージコミットを作りたくない
- リモートに追いつくだけの場合
- コンフリクトを避けたい

```bash
# Fast-forward可能 → 成功
A - B - C (main)
     \
      D - E (origin/main)

# Fast-forward不可 → エラー
A - B - C (main)
     \
      D (origin/main)
```

## 実践：pullの内部を確認

```bash
# 1. リモート追跡ブランチの状態を確認
git log --oneline main
git log --oneline origin/main

# 2. 差分を確認
git log main..origin/main      # リモートの新しいコミット
git log origin/main..main      # ローカルの新しいコミット

# 3. fetchのみ実行
git fetch origin main

# 4. リモート追跡ブランチの更新を確認
cat .git/refs/remotes/origin/main
# d3c2b1a789...（更新された）

# 5. ローカルブランチは未変更
cat .git/refs/heads/main
# a1b2c3d456...（変更なし）

# 6. マージを実行
git merge origin/main

# 7. ローカルブランチが更新された
cat .git/refs/heads/main
# d3c2b1a789...（更新された）
```

## トラブルシューティング

### エラー1: "fatal: refusing to merge unrelated histories"

```bash
git pull origin main
# fatal: refusing to merge unrelated histories
```

**原因：**
- 共通の履歴を持たない2つのリポジトリ

**解決：**

```bash
# 強制的にマージを許可
git pull origin main --allow-unrelated-histories
```

### エラー2: "Your local changes would be overwritten"

```bash
git pull origin main
# error: Your local changes to the following files would be overwritten by merge:
#     file.txt
# Please commit your changes or stash them before you merge.
```

**原因：**
- ワークツリーに未コミットの変更がある
- pullで上書きされる可能性

**解決方法：**

```bash
# 方法1: コミット
git add .
git commit -m "Save work"
git pull origin main

# 方法2: stash（一時保存）
git stash
git pull origin main
git stash pop

# 方法3: 変更を破棄
git checkout -- file.txt
git pull origin main
```

### エラー3: "divergent branches"

```bash
git pull origin main
# hint: You have divergent branches and need to specify how to reconcile them.
```

**原因：**
- Git 2.27以降のデフォルト動作変更
- pull時の挙動を明示的に指定する必要

**解決：**

```bash
# 方法1: マージ（デフォルト）
git config pull.rebase false
git pull origin main

# 方法2: リベース
git config pull.rebase true
git pull origin main

# 方法3: Fast-forwardのみ
git config pull.ff only
git pull origin main
```

## まとめ

### git pullの内部実装

```
git pull origin main
    ↓
1. git fetch origin main
   - リモートのオブジェクトをダウンロード
   - .git/objects/ に保存
   - refs/remotes/origin/main を更新
    ↓
2. git merge origin/main
   - 共通祖先を探す
   - Fast-forward または 3-way merge
   - refs/heads/main を更新
   - ワークツリーを更新
```

### 紐付け情報の保存場所

```
.git/config
[remote "origin"]
    url = https://github.com/user/repo.git
    fetch = +refs/heads/*:refs/remotes/origin/*

[branch "main"]
    remote = origin
    merge = refs/heads/main
```

### リモート追跡ブランチ

```
.git/refs/
├── heads/main           ← ローカルブランチ（あなたの作業）
└── remotes/origin/main  ← リモート追跡ブランチ（最後のfetch時の状態）
```

### 推奨ワークフロー

```bash
# 1. 安全にfetchで確認
git fetch origin main
git log main..origin/main

# 2. 問題なければマージ
git merge origin/main

# または一気に
git pull origin main
```

Gitの内部実装を理解することで、pullやoriginの動作が明確になります！
